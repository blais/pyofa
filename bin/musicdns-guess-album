#!/usr/bin/env python
"""Guess release from audio files in a directory.

Given a directory containing all and only the files of a single album, apply
some simple heuristics using the track numbers from the filenames, the PUIDs of
the sound files and the MusicBrainz database to automatically guess what is the
release that corresponds to this directory. Note that no use is made of header
tags.
"""

__author__ = 'Martin Blais <blais@furius.ca>'

# stdlib imports
import sys, os, re, logging, StringIO
from os.path import *
from collections import defaultdict
from operator import itemgetter

# musicdns imports
import musicdns, musicdns.cache

# mutagen imports
from mutagen import File

# musicbrainz imports
from musicbrainz2.webservice import Query, TrackFilter, WebServiceError, ReleaseIncludes


output_filename = 'saved.mb.release-id'

valid_extensions = ('.mp3', '.m4a', '.m4p', '.off', '.wav')

def process_dir(dn, musicdns_key):
    dn = abspath(dn)
    files = [join(dn, x) for x in os.listdir(dn)]

    # Create a list of (track, filename, puid).
    nfiles = []
    for fn in files:
        if splitext(fn)[1] not in valid_extensions:
            continue
        try:
            puid, _ = cache.getpuid(fn, musicdns_key)
        except IOError:
            puid = None
        track = filename_track_number(fn)
        nfiles.append((track, fn, puid))
    nfiles.sort()

    # Output text.
    o = StringIO.StringIO()
    def write(s):
        ss = s + u'\n'
        o.write(ss)
        sys.stdout.write(ss.encode('latin1', 'replace'))
        sys.stdout.flush()

    # For each track, filter the releases by including only those whose track
    # number matches the filename track number.
    matchrel = defaultdict(int)
    for i, (no, fn, puid) in enumerate(nfiles):
        write(u'')
        write(fn)
        if puid is None:
            continue
        for tno, track, release in find_releases(puid):
            # If the track numbers match, include the release in matches.
            included = 0
            if no == tno:
                matchrel[release.id] += 1
                included = 1
            write(u'    %d - %s - %s %s' % (tno, track.title, release.title,
                                            '***' if included else ''))

    write('')
    write('Matching releases:')
    write('')
    q = Query()
    i = ReleaseIncludes(
        artist=True,
        tracks=True,
        urlRelations=True,
        labels=True,
        )
    releaseids = sorted(matchrel.iteritems(), key=itemgetter(1), reverse=1)
    releases = [(q.getReleaseById(rid, i), freq) for rid, freq in releaseids]
    for rel, freq in releases:
        write(u'  (Frequency): %d' % freq)
        write(u'  Title: %s' % rel.title)
        write(u'  Artist: %s' % rel.artist.name)
        write(u'')
        for no, trk in enumerate(rel.tracks):
            write(u'    %d. %s' % ((no+1), trk.title))
        write(u'')
        
        # Skip the releases whose number of tracks do not match.
        if len(rel.getTracks()) != len(nfiles):
            logging.warning("Unmatched number of tracks.")

    # Select the most appropriate one.
    if releases:
        maxfreq = max(freq for rel, freq in releases)
        mreleases = [rel for rel, freq in releases if freq == maxfreq]

        ntmatches = [rel for rel in mreleases if len(rel.getTracks()) == len(nfiles)]
        chosen = ntmatches[0] if ntmatches else mreleases[0]
    else:
        chosen = None

    return chosen, o.getvalue()


def filename_track_number(fn):
    """Given filename, attempt to find the track numbers from the filenames."""
    mo = re.search('([0-9]+)', basename(fn))
    if mo:
        return int(mo.group(1))
        
def find_releases(puid):
    """Given a track's puid, return a list of
      (track-no, track, release)
    for each release that the song appeared on on."""
    q = Query()
    f = TrackFilter(puid=puid)
    results = q.getTracks(f)

    out = []
    for r in results:
        track = r.track
        rels = track.getReleases()
        assert len(rels) == 1
        rel = rels[0]
        out.append((rel.getTracksOffset()+1, track, rel))
    return out

def main():
    import optparse
    parser = optparse.OptionParser(__doc__.strip())

    parser.add_option('-k', '--musicdns-key', action='store_true',
                      help="Music DNS key")

    opts, args = parser.parse_args()

    if not opts.musicdns_key:
        keyfn = join(os.environ['HOME'], '.musicdns_key')
        opts.musicdns_key = open(keyfn).read().strip()

    musicdns.initialize()
        
    global cache; cache = musicdns.cache.MusicDNSCache()

    for dn in args:
        dn = abspath(dn)
        if not isdir(dn):
            continue
        print '... Processing %s ...' % dn
        release, text = process_dir(dn, opts.musicdns_key)
        f = open(join(dn, output_filename), 'w')
        if release is not None:
            f.write(basename(release.id) + '\n\n')
            f.write(release.id + '.html\n')
        else:
            f.write('\n\n\n')
        f.write('\n')
        f.write(text.encode('utf8', 'replace'))
        f.close()

    musicdns.finalize()

if __name__ == '__main__':
    main()

